
<!-- Polymer / Firebase -->
<link rel="import" href="../bower_components/polymer/polymer.html">

<link rel="import" href="../bower_components/iron-list/iron-list.html">
<link rel="import" href="../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../bower_components/iron-icons/iron-icons.html">

<link rel="import" href="../bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../bower_components/paper-tabs/paper-tab.html">
<link rel="import" href="../bower_components/paper-tabs/paper-tabs.html">
<link rel="import" href="../bower_components/paper-card/paper-card.html">
<link rel="import" href="../bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-dialog-scrollable/paper-dialog-scrollable.html">

<link rel="import" href="../bower_components/neon-animation/animations/scale-up-animation.html">
<link rel="import" href="../bower_components/neon-animation/animations/fade-out-animation.html">

<link rel="import" href="../bower_components/polymerfire/firebase-query.html">
<link rel="import" href="../bower_components/polymerfire/firebase-document.html">

<!-- Bloombox Commons -->
<link rel="import" href="../bower_components/bloombox-styles/bloombox-styles.html">
<link rel="import" href="../bower_components/bloombox-menutools/bloombox-menutools.html">

<!-- Product Listings -->
<link rel="import" href="../bower_components/bloombox-product-list/bloombox-product-list.html">

<!-- Product Cards -->
<link rel="import" href="../bower_components/bloombox-strain/bloombox-strain.html">
<link rel="import" href="../bower_components/bloombox-edible/bloombox-edible.html">
<link rel="import" href="../bower_components/bloombox-preroll/bloombox-preroll.html">
<link rel="import" href="../bower_components/bloombox-cartridge/bloombox-cartridge.html">
<link rel="import" href="../bower_components/bloombox-apothecary/bloombox-apothecary.html">
<link rel="import" href="../bower_components/bloombox-concentrate/bloombox-concentrate.html">


<dom-module id="bloombox-page-menu">
  <template strip-whitespace>
    <style is="custom-style" include="bloombox-styles">
      :root {
        --bloombox-product-list-width: 420px;
        --paper-fab-background: #4c9d2f;
      }

      :host {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border-left: 1px solid #ddd;
      }

      h1 {
        font-size: 28px;
        margin: 16px 0;
        color: #212121;
      }

      paper-button.addEntryButton {
        color: #333;
        min-width: 150px;
        background: #fefefe;
        margin-bottom: 40px;
        font-size: 80%;
        text-transform: uppercase;
      }

      paper-button.addEntryButton iron-icon {
        width: 16px;
        height: 16px;
        margin-right: 5px;
      }

      :host paper-card.menutools-container {
        width: 100%;
      }

      :host paper-card.menutools-container {
        background-color: white;
        width: 100%;
      }

      :host paper-card.menutools-container .card-content {
        background-color: white;
        padding: 12px;
      }

      :host paper-tab.iron-selected {
        font-weight: bold;
      }

      :host bloombox-strain,
      :host bloombox-apothecary,
      :host bloombox-edible,
      :host bloombox-concentrate,
      :host bloombox-cartridge,
      :host bloombox-preroll {
        margin-bottom: 20px;
        width: 100%;
      }

      :host .menu-content {
        margin-top: 20px;
      }

      :host bloombox-product-list {
        width: 420px;
        height: 100%;
        flex: 1 0 400px;
      }

      :host div.product-detail-pane {
        min-height: 400px;
        position: relative;
        flex: 1 1 60%;
        padding: 20px;
      }

      :host #menuWrap {
        display: flex;
        background-color: #fefefe;
        margin-top: 142px;
      }

      :host #productsContainer {
        position: relative;
      }

      :host #menuPages {
        flex: 1 1 300px;
        display: flex;
        overflow-y: scroll;
      }

      :host .selected-products {
        flex: 1 1 80%;
        padding: 20px;
      }

      :host .selected-products h2 {
        margin-left: 5px;
      }

      :host .bulk-actions {
        position: absolute;
        bottom: 40px;
      }

      :host .menu-page {
        display: flex;
        flex: 1 1 80%;
      }

      :host paper-tab[disabled] {
        opacity: 0.7;
      }

      :host #addObjectButton {
        position: absolute;
        bottom: 50px;
        right: 60px;
        height: 70px;
        width: 70px;
      }

      :host paper-dialog paper-toast.validation-toast {
        margin-left: 15px;
      }

      .zero-state-dialog paper-dialog-scrollable .zerostate-component {
        min-width: 600px;
      }
    </style>

    <!-- Firebase Collections -->
    <firebase-document
      id="dataCollection"
      log$="[[debug]]"
      path="[[_menuEndpoint]]/[[section]]"
      data="{{products}}"></firebase-document>

    <div class="zerostate-dialogs">
      <!-- Flower Zerostate -->
      <paper-dialog id="flowersCreateDialog" always-on-top modal class="product-zero-state zero-state-dialog">
        <h2>Create a Flower</h2>
        <paper-dialog-scrollable style="min-width: 600px;">
          <div hidden class="hidden zerostate-template" strip-whitespace>
            <bloombox-strain zerostate class="zerostate-component"></bloombox-strain>
          </div>
          <div class="product-zero-state-content">
          </div><!-- end div.product-zero-state-content -->
        </paper-dialog-scrollable>
        <div class="buttons">
          <paper-button class="discardButton" dialog-dismiss>Discard</paper-button>
          <paper-button class="confirmButton" autofocus on-tap="_saveZerostate">Create</paper-button>
        </div>
        <paper-toast always-on-top text="Please fill in all required fields." class="validation-toast bottom notification-toast"></paper-toast>
      </paper-dialog>

      <!-- Edible Zerostate -->
      <paper-dialog id="ediblesCreateDialog" always-on-top modal class="product-zero-state zero-state-dialog">
        <h2>Create an Edible</h2>
        <paper-dialog-scrollable style="min-width: 600px;">
          <div hidden class="hidden zerostate-template" strip-whitespace>
            <bloombox-edible zerostate class="zerostate-component"></bloombox-edible>
          </div>
          <div class="product-zero-state-content">
          </div><!-- end div.product-zero-state-content -->
        </paper-dialog-scrollable>
        <div class="buttons">
          <paper-button class="discardButton" dialog-dismiss>Discard</paper-button>
          <paper-button class="confirmButton" autofocus on-tap="_saveZerostate">Create</paper-button>
        </div>
        <paper-toast always-on-top text="Please fill in all required fields." class="validation-toast bottom notification-toast"></paper-toast>
      </paper-dialog>

      <!-- Concentrate Zerostate -->
      <paper-dialog id="concentratesCreateDialog" always-on-top modal class="product-zero-state zero-state-dialog">
        <h2>Create a Concentrate</h2>
        <paper-dialog-scrollable style="min-width: 600px;">
          <div hidden class="hidden zerostate-template" strip-whitespace>
            <bloombox-concentrate zerostate class="zerostate-component"></bloombox-concentrate>
          </div>
          <div class="product-zero-state-content">
          </div><!-- end div.product-zero-state-content -->
        </paper-dialog-scrollable>
        <div class="buttons">
          <paper-button class="discardButton" dialog-dismiss>Discard</paper-button>
          <paper-button class="confirmButton" autofocus on-tap="_saveZerostate">Create</paper-button>
        </div>
        <paper-toast always-on-top text="Please fill in all required fields." class="validation-toast bottom notification-toast"></paper-toast>
      </paper-dialog>

      <!-- Pre-Roll Zerostate -->
      <paper-dialog id="prerollsCreateDialog" always-on-top modal class="product-zero-state zero-state-dialog">
        <h2>Create a Pre-Roll</h2>
        <paper-dialog-scrollable style="min-width: 600px;">
          <div hidden class="hidden zerostate-template" strip-whitespace>
            <bloombox-preroll zerostate class="zerostate-component"></bloombox-preroll>
          </div>
          <div class="product-zero-state-content">
          </div><!-- end div.product-zero-state-content -->
        </paper-dialog-scrollable>
        <div class="buttons">
          <paper-button class="discardButton" dialog-dismiss>Discard</paper-button>
          <paper-button class="confirmButton" autofocus on-tap="_saveZerostate">Create</paper-button>
        </div>
        <paper-toast always-on-top text="Please fill in all required fields." class="validation-toast bottom notification-toast"></paper-toast>
      </paper-dialog>

      <!-- Apothecary Zerostate -->
      <paper-dialog id="apothecaryCreateDialog" always-on-top modal class="product-zero-state zero-state-dialog">
        <h2>Create an Apothecary item</h2>
        <paper-dialog-scrollable style="min-width: 600px;">
          <div hidden class="hidden zerostate-template" strip-whitespace>
            <bloombox-apothecary zerostate class="zerostate-component"></bloombox-apothecary>
          </div>
          <div class="product-zero-state-content">
          </div><!-- end div.product-zero-state-content -->
        </paper-dialog-scrollable>
        <div class="buttons">
          <paper-button class="discardButton" dialog-dismiss>Discard</paper-button>
          <paper-button class="confirmButton" autofocus on-tap="_saveZerostate">Create</paper-button>
        </div>
        <paper-toast always-on-top text="Please fill in all required fields." class="validation-toast bottom notification-toast"></paper-toast>
      </paper-dialog>

      <!-- Cartridge Zerostate -->
      <paper-dialog id="cartridgesCreateDialog" always-on-top modal class="product-zero-state zero-state-dialog">
        <h2>Create a Cartridge</h2>
        <paper-dialog-scrollable style="min-width: 600px;">
          <div hidden class="hidden zerostate-template" strip-whitespace>
            <bloombox-cartridge zerostate class="zerostate-component"></bloombox-cartridge>
          </div>
          <div class="product-zero-state-content">
          </div><!-- end div.product-zero-state-content -->
        </paper-dialog-scrollable>
        <div class="buttons">
          <paper-button class="discardButton" dialog-dismiss>Discard</paper-button>
          <paper-button class="confirmButton" autofocus on-tap="_saveZerostate">Create</paper-button>
        </div>
        <paper-toast always-on-top text="Please fill in all required fields." class="validation-toast bottom notification-toast"></paper-toast>
      </paper-dialog>
    </div><!-- end div.zerostate-dialogs -->

    <!-- Card UI -->
    <paper-card class="fullwidth menutools-container">
      <div class="menu-tools toolbar-content card-content">
        <bloombox-menutools
          instock="{{instock}}"
          sale="{{onsale}}"
          display-mode="{{_menuDisplayMode}}"
          locations="[[locations]]"
          location="{{location}}"
          has-tests="{{hasTests}}"
          disabled="[[loading]]"></bloombox-menutools>
      </div><!-- end div.toolbar-content.card-content -->

      <!-- Menu Navigation (categories) -->
      <div class="menu-nav">
        <paper-tabs selected="{{section}}" attr-for-selected="key" noink disabled="[[loading]]">
          <paper-tab key="flowers">Flowers</paper-tab>
          <paper-tab key="edibles">Edibles</paper-tab>
          <paper-tab key="concentrates">Concentrates</paper-tab>
          <paper-tab key="prerolls">Pre-Rolls</paper-tab>
          <paper-tab key="apothecary">Apothecary</paper-tab>
          <paper-tab key="cartridges">Cartridges</paper-tab>
        </paper-tabs>
      </div><!-- end div.menu-nav -->
    </paper-card><!-- end .paper-card.menutools-container -->

    <div id="menuWrap" class="menu-content layout fit">
      <div id="productsContainer" class="products-list-container layout fit vertical">
        <bloombox-product-list
          id="productList"
          section="[[section]]"
          heading="[[heading]]"
          products="[[products]]"
          selected-items="{{_selected}}"
          search="{{search}}"
          instock-only="[[instock]]"
          sale-only="[[onsale]]"
          has-tests-only="[[hasTests]]"
          multiselect="{{multiselect}}"
          partner="[[partner]]"></bloombox-product-list>
      </div><!-- end div.products-list-container -->

      <template is="dom-if" if="[[multiselect]]" strip-whitespace>
        <div class="selected-products">
          <template is="dom-if" if="[[_hasSelectedItems]]" strip-whitespace>
            <h2>Selected products:</h2>
            <ul>
            <template class="multiselect-list" is="dom-repeat" items="[[selectedItems]]" strip-whitespace>
              <li>[[item.value.name]]</li>
            </template>
            </ul>
          </template>
          <template is="dom-if" if="[[!_hasSelectedItems]]" strip-whitespace>
            <h2>Select multiple products to perform bulk edits.</h2>
          </template>

          <div class="bulk-actions">
            <paper-button raised on-tap="bulkMarkAsInStock" disabled="[[!_hasSelectedItems]]"><iron-icon icon="done"></iron-icon>Mark as In-Stock</paper-button>
            <paper-button raised on-tap="bulkMarkAsOutOfStock" disabled="[[!_hasSelectedItems]]"><iron-icon icon="clear"></iron-icon>Mark as Out of Stock</paper-button>
            <paper-button raised on-tap="bulkDelete" disabled="[[!_hasSelectedItems]]"><iron-icon icon="delete"></iron-icon>Delete</paper-button>
          </div><!-- end div.bulk-actions -->
        </div><!-- end div.selected-products -->
      </template>

      <iron-pages id="menuPages" selected="{{section}}" attr-for-selected="section" hidden$="[[multiselect]]">
        <div class="menu-page flowers-menu-page" section="flowers">
          <!-- Product Detail -->
          <div class="product-detail-pane">
            <bloombox-strain
              key="[[selectedItem.key]]"
              partner="[[partner]]"
              environment="[[environment]]"
              name="[[selectedItem.value.name]]"
              pricing="[[formatPricelist(selectedItem.value.pricelist)]]"
              grow="[[_processGrowValue(selectedItem.value.grow)]]"
              species="[[_processSpeciesValue(selectedItem.value.species)]]"
              visible="[[_processVisible(selectedItem.value.flags.visible)]]"
              description$="[[selectedItem.value.description]]"
              tests$="[[_processTests(selectedItem.value.tests)]]"
              ancestry$="[[selectedItem.value.ancestry]]"
              sale$="[[selectedItem.value.flags.sale]]"
              bogo$="[[selectedItem.value.flags.bogo]]"
              premium$="[[selectedItem.value.flags.premium]]"
              pictures$="[[selectedItem.value.pictures]]"
              hidden$="[[!selectedItem]]"
              disabled="[[loading]]"></bloombox-strain><!-- end bloombox-strain -->
          </div><!-- end div.product-detail-pane -->
        </div><!-- end div.menu-page.flowers-menu-page -->

        <div class="menu-page edibles-menu-page" section="edibles">
          <!-- Product Detail -->
          <div class="product-detail-pane">
            <bloombox-edible
              key="[[selectedItem.key]]"
              partner="[[partner]]"
              environment="[[environment]]"
              name="[[selectedItem.value.name]]"
              brand="[[selectedItem.value.brand]]"
              type="[[selectedItem.value.type]]"
              pricing="[[selectedItem.value.pricing]]"
              visible="[[_processVisible(selectedItem.value.flags.visible)]]"
              description$="[[selectedItem.value.description]]"
              tests$="[[_processTests(selectedItem.value.tests)]]"
              sale$="[[selectedItem.value.flags.sale]]"
              bogo$="[[selectedItem.value.flags.bogo]]"
              premium$="[[selectedItem.value.flags.premium]]"
              vegan$="[[selectedItem.value.flags.vegan]]"
              organic$="[[selectedItem.value.flags.organic]]"
              glutenfree$="[[selectedItem.value.flags.glutenfree]]"
              sugarfree$="[[selectedItem.value.flags.sugarfree]]"
              photos$="[[selectedItem.value.photos]]"
              hidden$="[[!selectedItem]]"
              disabled="[[loading]]"></bloombox-edible><!-- end bloombox-edible -->
            </div><!-- end div.product-detail-pane -->
        </div><!-- end div.menu-page.edibles-menu-page -->

        <div class="menu-page concentrates-menu-page" section="concentrates">
          <div class="product-detail-pane">
            <bloombox-concentrate
              key="[[selectedItem.key]]"
              partner="[[partner]]"
              environment="[[environment]]"
              name="[[selectedItem.value.name]]"
              brand="[[selectedItem.value.brand]]"
              type="[[selectedItem.value.type]]"
              pricing="[[selectedItem.value.pricing]]"
              visible="[[_processVisible(selectedItem.value.flags.visible)]]"
              description$="[[selectedItem.value.description]]"
              tests$="[[_processTests(selectedItem.value.tests)]]"
              sale$="[[selectedItem.value.flags.sale]]"
              bogo$="[[selectedItem.value.flags.bogo]]"
              premium$="[[selectedItem.value.flags.premium]]"
              photos$="[[selectedItem.value.photos]]"
              hidden$="[[!selectedItem]]"
              disabled="[[loading]]"></bloombox-concentrate><!-- end bloombox-concentrate -->
          </div><!-- end div.product-detail-pane -->
        </div><!-- end div.menu-page.concentrates-menu-page -->

        <div class="menu-page prerolls-menu-page" section="prerolls">
          <div class="product-detail-pane">
            <bloombox-preroll
              key="[[selectedItem.key]]"
              partner="[[partner]]"
              environment="[[environment]]"
              name="[[selectedItem.value.name]]"
              brand="[[selectedItem.value.brand]]"
              type="[[selectedItem.value.type]]"
              pricing="[[selectedItem.value.pricing]]"
              grow="[[_processGrowValue(selectedItem.value.grow)]]"
              species="[[_processSpeciesValue(selectedItem.value.species)]]"
              visible="[[_processVisible(selectedItem.value.flags.visible)]]"
              description$="[[selectedItem.value.description]]"
              tests$="[[_processTests(selectedItem.value.tests)]]"
              sale$="[[selectedItem.value.flags.sale]]"
              bogo$="[[selectedItem.value.flags.bogo]]"
              premium$="[[selectedItem.value.flags.premium]]"
              photos$="[[selectedItem.value.photos]]"
              hidden$="[[!selectedItem]]"
              disabled="[[loading]]"></bloombox-preroll><!-- end bloombox-preroll -->
          </div>
        </div><!-- end div.menu-page.prerolls-menu-page -->

        <div class="menu-page apothecary-menu-page" section="apothecary">
          <div class="product-detail-pane">
            <bloombox-apothecary
              key="[[selectedItem.key]]"
              partner="[[partner]]"
              environment="[[environment]]"
              name="[[selectedItem.value.name]]"
              brand="[[selectedItem.value.brand]]"
              type="[[selectedItem.value.type]]"
              pricing="[[selectedItem.value.pricing]]"
              visible="[[_processVisible(selectedItem.value.flags.visible)]]"
              description$="[[selectedItem.value.description]]"
              tests$="[[_processTests(selectedItem.value.tests)]]"
              sale$="[[selectedItem.value.flags.sale]]"
              bogo$="[[selectedItem.value.flags.bogo]]"
              premium$="[[selectedItem.value.flags.premium]]"
              photos$="[[selectedItem.value.photos]]"
              hidden$="[[!selectedItem]]"
              disabled="[[loading]]"></bloombox-apothecary><!-- end bloombox-apothecary -->
          </div><!-- end div.product-detail-pane -->
        </div><!-- end div.menu-page.apothecary-menu-page -->

        <div class="menu-page cartridges-menu-page" section="cartridges">
          <div class="product-detail-pane">
            <bloombox-cartridge
              key="[[selectedItem.key]]"
              partner="[[partner]]"
              environment="[[environment]]"
              name="[[selectedItem.value.name]]"
              brand="[[selectedItem.value.brand]]"
              type="[[selectedItem.value.type]]"
              pricing="[[selectedItem.value.pricing]]"
              visible="[[_processVisible(selectedItem.value.flags.visible)]]"
              description$="[[selectedItem.value.description]]"
              tests$="[[_processTests(selectedItem.value.tests)]]"
              sale$="[[selectedItem.value.flags.sale]]"
              bogo$="[[selectedItem.value.flags.bogo]]"
              premium$="[[selectedItem.value.flags.premium]]"
              photos$="[[selectedItem.value.photos]]"
              hidden$="[[!selectedItem]]"
              disabled="[[loading]]"></bloombox-cartridge><!-- end bloombox-cartridge -->
          </div><!-- end div.product-detail-pane -->
        </div><!-- end div.menu-page.cartridges-menu-page -->
      </iron-pages><!-- end iron-pages#menuPages -->

      <paper-fab id="addObjectButton" on-tap="_showZerostate" icon="add"></paper-fab>

    </div><!-- end div#menuWrap.menu-content -->
  </template>

  <script>
    var BloomboxLocationCache = {};

    Polymer.BloomboxPageMenu = Polymer({
      is: 'bloombox-page-menu',
      properties: {
        _menuEndpoint: {
          type: String,
          notify: true,
          computed: '_computeMenuEndpoint(endpoint, location)'
        },

        _hasSelectedItems: {
          type: Boolean,
          notify: true,
          computed: '_computeHasSelectedItems(multiselect, selectedItems)'
        },

        debug: {
          type: Boolean,
          notify: true,
          value: function() {
            return window && window["__debug"] || false;
          }
        },

        zerostate: {
          type: Boolean,
          notify: true,
          value: false
        },

        loading: {
          type: Boolean,
          notify: true
        },

        storage: {
          type: String,
          notify: true
        },

        partner: {
          type: String,
          notify: true
        },

        products: {
          type: Object,
          notify: true,
        },

        section: {
          type: String,
          notify: true,
          value: 'flowers'
        },

        heading: {
          type: String,
          notify: true,
          computed: '_computeSectionHeading(section)'
        },

        locations: {
          type: Array,
          notify: true,
          observer: '_locationsLoaded',
          value: function() {
            return window["bloom"] ? bloom.app.locations : [];
          }
        },

        location: {
          type: String,
          notify: true,
          observer: '_locationChanged'
        },

        instock: {
          type: Boolean,
          value: true,
          notify: true
        },

        hasTests: {
          type: String,
          value: "all",
          notify: true
        },

        endpoint: {
          type: String,
          notify: true
        },

        multiselect: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true,
          value: false
        },

        _selected: {
          type: Array,
          notify: true
        },

        selectedItem: {
          type: Object,
          notify: true
        },

        selectedItems: {
          type: Array,
          notify: true,
          computed: '_computeSelectedItems(multiselect, _selected.*)'
        },

        search: {
          type: String,
          nofity: true
        }
      },

      _toArray: function(obj) {
        return Object.keys(obj).map(function(key) {
          return {
            key: key,
            value: obj[key]
          };
        });
      },

      _computeMenuEndpoint: function(endpoint, location) {
        return endpoint + "/locations/" + location + "/menu";
      },

      _computeSectionHeading: function(section) {
        // @TODO: better section heading definitions
        return section.charAt(0).toUpperCase() + section.slice(1);
      },

      _computeSelectedItems: function(multiselect, selected) {
        if (multiselect != true) {
          if (Array.isArray(selected.base) && selected.base.length > 0) {
            this.selectedItem = selected.base[0];
            return selected.base;
          }
          if (selected.value !== null && typeof selected.value === "object" && typeof selected.value.key === "string") {
            this.selectedItem = selected.value;
            return [selected.value];
          }
        } else {
          if (Array.isArray(selected.base) && selected.base.length > 0) {
            this.selectedItem = null;
            this._selectedItemsDidChange();
            return selected.base;
          }
        }
        this.selectedItem = null;
        return [];
      },

      _selectedItemsDidChange: function() {
        var lists = Polymer.dom(this.root).querySelectorAll(".multiselect-list"),
            i;
        if (lists && lists.length > 0) {
          for (i in lists) {
            lists[i].render();
          }
        }
      },

      _locationsLoaded: function(locations) {
        var location = this.location;

        BloomboxLocationCache = {};
        for (l in locations) {
          BloomboxLocationCache[locations[l].key] = locations[l];
        }

        if (location == null || location == undefined) {
          this.location = locations[0].key;
        }
      },

      _processVisible: function(flagValue) {
        if (flagValue === false)
          return false;
        return true;
      },

      _processGrowValue: function(grow) {
        if (grow != null && grow != undefined && typeof grow === "string")
          return grow;
        return "Unknown Grow";
      },

      _processSpeciesValue: function(species) {
        if (species != null && species != undefined && typeof species === "string")
          return species;
        return "Unknown Species";
      },

      _processTests: function(tests) {
        if (tests != null && tests != undefined && typeof tests === "object") {
          if (tests.terpenes != null && tests.terpenes != undefined && typeof tests.terpenes === "object") {
            return {
              cbd: tests.cbd || 0,
              thc: tests.thc || 0,
              terpenes: tests.terpenes
            };
          }
          return {
            cbd: tests.cbd || 0,
            thc: tests.thc || 0
          };
        }
        return false;  // removes the `tests` attribute entirely
      },

      _locationChanged: function(location) {
        console.info("Loading menu for location '" + location + "'...");
      },

      _shouldHideProduct: function(instock, product) {
        if (instock && product && product.value && product.value.flags && !product.value.flags.visible)
          return true;
        return false;
      },

      _computeHasSelectedItems: function(multiselect, selectedItems) {
        return (multiselect == true && Array.isArray(selectedItems) && selectedItems.length > 0);
      },

      _showZerostate: function() {
        var dialog = this.$[this.section + "CreateDialog"],
            body = document.querySelector('body'),
            node = Polymer.dom(dialog).node,
            discard = node.querySelector(".discardButton"),
            confirm = node.querySelector(".confirmButton"),
            template = node.querySelector(".zerostate-template"),
            content = node.querySelector(".product-zero-state-content");
        Polymer.dom(content).innerHTML = template.innerHTML;  // forcibly re-render zerostate component
        body.appendChild(dialog);  // @TODO(sgammon): fix positioning when using a backdrop
        dialog.style.marginBottom = "150px";
        dialog.style.marginTop = "150px";
        discard.style.position = "absolute";
        discard.style.left = "10px";
        confirm.style.fontWeight = "bold";
        dialog.open();
      },

      _saveZerostate: function() {
        var dialog = this.$[this.section + "CreateDialog"],
            node = Polymer.dom(dialog).node,
            content = node.querySelector(".product-zero-state-content").children[0],
            actionsContainer = node.querySelector(".buttons")
            errorToast = node.querySelector(".validation-toast");
        errorToast.fitInto = actionsContainer;
        errorToast.style.backgroundColor = "#FFC107";
        errorToast.style.color = "#333";
        errorToast.style.lineHeight = "48px";
        errorToast.style.marginLeft = "0";
        errorToast.style.marginBottom = "-75px";
        content.persist(function(error) {
          var that = this;
          if (error) {
            if (typeof error === "string") {
              errorToast.text = error;
            }
            errorToast.open();
          } else {
            // we created the object successfully
            dialog.close();
            setTimeout(function() {
              bloom.app.successToast("Successfully created " + (that.readZeroStateForm().name || "a new product") + ".");
            }, 120);
          }
        });
      },

      _applyWritesToProducts: function(schema, products, isDelete, callback) {
        var updates = {}, i, p, schema;
        if (!Array.isArray(products) || products.length < 1) {
          callback(false);
          return;
        }

        // map writes into one bulk update
        for (i in products) {
          p = products[i];
          updates[p.key] = isDelete ? null : p.value;
        }

        return this.$.dataCollection.ref
                            .update(updates)
                            .then(function() {
                              callback(true);
                            })
                            .catch(function(error) {
                              console.error("Encountered error persisting edits for object of type '" + schema + "'.", error);
                              callback(false, error);
                            });
      },

      _mapForEachProduct: function(products, callback) {
        var i, p, processed = [], buffered = JSON.parse(JSON.stringify(products));
        if (Array.isArray(buffered) && buffered.length > 0) {
          for (i in buffered) {
            p = buffered[i];
            callback(p);
            processed.push(p);
          }
          return processed;
        }
        return [];
      },

      formatPricelist: function(pricelist) {
        if (pricelist == null) {
          return [];
        }
        return [
          {"label": "1g", "available": pricelist["gram"]["available"], "price": pricelist["gram"]["price"]},
          {"label": "3.5g", "available": pricelist["eighth"]["available"], "price": pricelist["eighth"]["price"]},
          {"label": "7g", "available": pricelist["quarter"]["available"], "price": pricelist["quarter"]["price"]},
          {"label": "14g", "available": pricelist["half"]["available"], "price": pricelist["half"]["price"]},
          {"label": "28g", "available": pricelist["ounce"]["available"], "price": pricelist["ounce"]["price"]}
        ];
      },

      toggleAddEntry: function(schema) {
        var section = (typeof schema === "string") ? schema : this.section,
            newObjEntry = this.$$("." + section + "-create-container .newEntry"),
            newObjButton = this.$$("." + section + "-menu-page .addEntryButton");

        if (newObjButton.hasAttribute("active") || newObjButton.active === true) {
          // button is active: show the component
          newObjEntry.removeAttribute("hidden");
          this.zerostate = true;
        } else {
          // button is not active: hide the component
          newObjEntry.setAttribute("hidden", true);
          this.zerostate = false;
        }
      },

      hideAddEntry: function(schema) {
        var section = (typeof schema === "string") ? schema : this.section,
            newObjEntry = this.$$("." + section + "-create-container .newEntry"),
            newObjButton = this.$$("." + section + "-menu-page .addEntryButton");

        newObjEntry.setAttribute("hidden", true);
        newObjButton.active = false;
        newObjButton.deleteAttribute("active");
      },

      attachAsset: function(mediaElement, callback) {
        // callback(uuid, error);
        var targetName = mediaElement.getNewFileName(),
            fileObject = mediaElement.getFile(),
            resolvedPath = this.generateAssetURL(targetName),
            firebase = window["firebase"] || this["firebase"] || null,
            uploadTask;
        if (firebase === null) {
          console.error("Unable to resolve Firebase library. Failing asset attachment call.");
          callback(null, "DATABASE_ERROR");
        } else {
          uploadTask = firebase.storage().ref.child(resolvedPath).put(fileObject.file);
          uploadTask.on("state_changed", function(snapshot) {
            // Handle progress events
            var progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
            console.info("Media upload completion: ", progress);
            mediaElement.setProgress(progress);
          }, function(error) {
            // Handle unsuccessful uploads
            console.error("Error occurred during media upload:", error);
            callback(null, error);
          }, function() {
            // Handle completion
            var downloadURL = uploadTask.snapshot.downloadURL;
            console.info("New asset is available at download URL: ", downloadURL);
            callback(targetName, undefined);
          });
        }
      },

      generateAssetURL: function(targetName) {
        var prefix = this.get("storage");
        if (!prefix)
          console.warn("Unable to resolve storage prefix. Uploads may break.");
        return prefix + "/" + targetName;
      },

      saveNewObject: function(schema, entry, component, callback) {
        var debug = window["__debug"] || false,
            that = this,
            newObjKey;

        // perform our object write
        newObjKey = this.$.dataCollection.ref.child(schema).push().key;
        if (debug) {
          console.info("Provisioned key: '" + newObjKey + "'.", entry);
        }
        return this.$.dataCollection.ref
                            .child(newObjKey)
                            .update(entry)
                            .then(function() {
                              console.info("Object was created successfully.");
                              if (callback !== undefined && typeof callback === "function") {
                                callback();
                              }
                            })
                            .catch(function(error) {
                              console.error("Encountered error persisting new object of type '" + schema + "'.", error);
                              if (callback !== undefined && typeof callback === "function") {
                                callback(error);
                              }
                            });
      },

      saveEditsForEntry: function(schema, key, previous, entry, callback) {
        var debug = window["__debug"] || false;
        if (debug) {
          console.info("Saving edits for item of type '" + schema + "' at key: '" + key + "'.", entry);
        }
        return this.$.dataCollection.ref
                            .child(key)
                            .update(entry)
                            .then(callback)
                            .catch(function(error) {
                              console.error("Encountered error persisting edits for object of type '" + schema + "'.", error);
                              callback(error);
                            });
      },

      deleteEntryAtId: function(schema, key, name) {
        var that = this;
        bloom.app.confirmToast("Are you sure you want to delete " + name + "?", function(yes, toast) {
          if (yes) {
            console.info("Deleting item of type '" + schema + "' at key '" + key + "'.");
            that.$.dataCollection.ref
                                .child(key)
                                .remove()
                                .then(function() {
                                  console.info("Delete operation succeeded.");
                                  toast.close();
                                  setTimeout(function() {
                                    bloom.app.successToast("Deleted " + name + ".");
                                  }, 120);
                                }).catch(function(error) {
                                  console.error("Failed to delete item.", error);
                                  toast.close();
                                  setTimeout(function() {
                                    bloom.app.errorToast("Failed to delete the item in question. Please refresh the page and try again.");
                                  }, 120);
                                });
            return true;  // we will close the dialog
          } else {
            console.info("User cancelled delete operation.");
          }
          return false;  // close the dialog for us
        });
      },

      clearSelection: function() {
        this.$.productList.clearSelection();
      },

      markAsInStock: function(item) {
        var that = this,
            schema = item._schema,
            key = item.key,
            obj = item.readObjectData(),
            writes = this._mapForEachProduct([{key: key, value: obj}], function(product) {
          if (product.value.flags !== undefined) {
            product.value.flags.visible = true;
          } else {
            product.value.flags = {
              visible: true
            };
          }
        });
        bloom.app.confirmToast("Mark " + obj.name + " as in-stock?", function(yes, toast) {
          if (yes) {
            console.info("User confirmed mark-as-in-stock operation. Executing...");
            that._applyWritesToProducts(schema, writes, false, function(success) {
              if (success) {
                console.info("Operation finished.");
                toast.close();
                setTimeout(function() {
                  bloom.app.successToast("Successfully marked " + obj.name + " as in-stock.");
                }, 120);
              } else {
                console.error("Failed to apply changes to item.");
                toast.close();
                setTimeout(function() {
                  bloom.app.errorToast("Failed to mark item as in-stock. Please refresh the page and try again.");
                });
              }
            });
            return true;
          } else {
            console.info("User rejected operation. Cancelling.");
          }
          return false;
        });
      },

      markAsOutOfStock: function(item) {
        var that = this,
            schema = item._schema,
            key = item.key,
            obj = item.readObjectData(),
            writes = this._mapForEachProduct([{key: key, value: obj}], function(product) {
          if (product.value.flags !== undefined) {
            product.value.flags.visible = false;
          } else {
            product.value.flags = {
              visible: false
            };
          }
        });
        bloom.app.confirmToast("Mark " + obj.name + " as out-of-stock?", function(yes, toast) {
          if (yes) {
            console.info("User confirmed mark-as-out-of-stock operation. Executing...");
            that._applyWritesToProducts(schema, writes, false, function(success) {
              if (success) {
                console.info("Operation finished.");
                toast.close();
                setTimeout(function() {
                  bloom.app.successToast("Successfully marked " + obj.name + " as out-of-stock.");
                }, 120);
              } else {
                console.error("Failed to apply changes to item.");
                toast.close();
                setTimeout(function() {
                  bloom.app.errorToast("Failed to mark item as out-of-stock. Please refresh the page and try again.");
                });
              }
            });
            return true;
          } else {
            console.info("User rejected operation. Cancelling.");
          }
          return false;
        });
      },

      bulkMarkAsInStock: function(event) {
        var products = this.selectedItems,
            that = this,
            section = this.section;
        event.preventDefault();
        event.stopPropagation();
        writes = this._mapForEachProduct(products, function(product) {
          if (product.value.flags !== undefined) {
            product.value.flags.visible = true;
          } else {
            product.value.flags = {
              visible: true
            };
          }
        });
        console.info("User requested bulk mark-as-in-stock:", products);
        bloom.app.confirmToast("Mark " +
                               (products.length > 1 ? products.length + " " : "") +
                               "selected " +
                               (products.length > 1 ? "items" : "item") + " as in stock?", function(yes, toast) {
                                  if (yes) {
                                    console.info("User confirmed bulk operation. Executing...");
                                    that._applyWritesToProducts(section, writes, false, function(success) {
                                      if (success) {
                                        // okay everything worked
                                        console.info("Bulk operation finished.");
                                        toast.close();
                                        setTimeout(function() {
                                          that.clearSelection();
                                          that.multiselect = false;
                                          bloom.app.successToast("Successfully marked " + products.length + " " +
                                                                (products.length > 1 ? "items" : "item") +
                                                                " as in-stock.")
                                        }, 120);
                                      } else {
                                        // something broke
                                        console.error("Failed to apply bulk operation.");
                                        toast.close();
                                        setTimeout(function() {
                                          bloom.app.errorToast("Bulk edit operation failed. Please try again.");
                                        });
                                      }
                                    });
                                    return true;  // we will handle closing it
                                  } else {
                                    console.info("User rejected bulk operation. Cancelling.");
                                  }
                                  return false;  // close the dialog for us plz
                               });
      },

      bulkMarkAsOutOfStock: function(event) {
        var products = this.selectedItems,
            that = this,
            section = this.section,
            writes;
        event.preventDefault();
        event.stopPropagation();
        writes = this._mapForEachProduct(products, function(product) {
          if (product.value.flags !== undefined) {
            product.value.flags.visible = false;
          } else {
            product.value.flags = {visible: false};
          }
        });
        console.info("User requested bulk mark-as-out-of-stock:", products);
        bloom.app.confirmToast("Mark " +
                               (products.length > 1 ? products.length + " " : "") +
                               "selected " +
                               (products.length > 1 ? "items" : "item") + " as out-of-stock?", function(yes, toast) {
                                  if (yes) {
                                    console.info("User confirmed bulk operation. Executing...");
                                    that._applyWritesToProducts(section, writes, false, function(success) {
                                      if (success) {
                                        // okay everything worked
                                        console.info("Bulk operation finished.");
                                        toast.close();
                                        setTimeout(function() {
                                          that.clearSelection();
                                          that.multiselect = false;
                                          bloom.app.successToast("Successfully marked " + products.length + " " +
                                                                (products.length > 1 ? "items" : "item") +
                                                                " as out-of-stock.")
                                        }, 120);
                                      } else {
                                        // something broke
                                        console.error("Failed to apply bulk operation.");
                                        toast.close();
                                        setTimeout(function() {
                                          bloom.app.errorToast("Bulk edit operation failed. Please try again.");
                                        });
                                      }
                                    });
                                    return true;  // we will handle closing it
                                  } else {
                                    console.info("User rejected bulk operation. Cancelling.");
                                  }
                                  return false;  // close the dialog for us plz
                               });
      },

      bulkDelete: function(event) {
        var products = this.selectedItems,
            that = this,
            section = this.section,
            writes;
        event.preventDefault();
        event.stopPropagation();
        console.info("User requested bulk delete:", products);
        bloom.app.confirmToast("Delete " +
                               (products.length > 1 ? products.length + " " : "") +
                               "selected " +
                               (products.length > 1 ? "items" : "item") + "?", function(yes, toast) {
                                  if (yes) {
                                    console.info("User confirmed bulk delete. Executing...");
                                    that._applyWritesToProducts(section, products, true, function(success) {
                                      if (success) {
                                        // okay everything worked
                                        console.info("Bulk delete operation finished.");
                                        toast.close();
                                        setTimeout(function() {
                                          that.clearSelection();
                                          that.multiselect = false;
                                          bloom.app.successToast("Successfully deleted " + products.length + " " +
                                                                (products.length > 1 ? "items" : "item") + ".")
                                        }, 120);
                                      } else {
                                        // something broke
                                        console.error("Failed to execute bulk delete operation.");
                                        toast.close();
                                        setTimeout(function() {
                                          bloom.app.errorToast("Bulk delete failed. Please try again.");
                                        });
                                      }
                                    });
                                    return true;  // we will handle closing it
                                  } else {
                                    console.info("User rejected bulk delete. Cancelling.");
                                  }
                                  return false;  // close the dialog for us plz
                               });
      },

      ready: function() {
        var bloom = window["bloom"];
        if (bloom !== undefined && bloom != null) {
          bloom.menu = this;  // provide menu engine to JS context
        } else {
          window["bloom"] = {
            menu: this
          };
        }
      }
    });
  </script>
</dom-module>
