
<!-- Polymer / Firebase -->
<link rel="import" href="../bower_components/polymer/polymer.html">

<link rel="import" href="../bower_components/iron-list/iron-list.html">
<link rel="import" href="../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../bower_components/iron-icons/iron-icons.html">

<link rel="import" href="../bower_components/paper-tabs/paper-tab.html">
<link rel="import" href="../bower_components/paper-tabs/paper-tabs.html">
<link rel="import" href="../bower_components/paper-card/paper-card.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">

<link rel="import" href="../bower_components/polymerfire/firebase-query.html">
<link rel="import" href="../bower_components/polymerfire/firebase-document.html">

<!-- Bloombox Commons -->
<link rel="import" href="../bower_components/bloombox-styles/bloombox-styles.html">
<link rel="import" href="../bower_components/bloombox-menutools/bloombox-menutools.html">

<!-- Product Listings -->
<link rel="import" href="../bower_components/bloombox-product-list/bloombox-product-list.html">

<!-- Product Cards -->
<link rel="import" href="../bower_components/bloombox-strain/bloombox-strain.html">
<link rel="import" href="../bower_components/bloombox-edible/bloombox-edible.html">
<link rel="import" href="../bower_components/bloombox-preroll/bloombox-preroll.html">
<link rel="import" href="../bower_components/bloombox-cartridge/bloombox-cartridge.html">
<link rel="import" href="../bower_components/bloombox-apothecary/bloombox-apothecary.html">
<link rel="import" href="../bower_components/bloombox-concentrate/bloombox-concentrate.html">


<dom-module id="bloombox-page-menu">
  <template>
    <style is="custom-style" include="bloombox-styles">
      :root {
        --bloombox-product-list-width: 420px;
      }

      :host {
        display: block;
        padding: 40px;
      }

      h1 {
        font-size: 28px;
        margin: 16px 0;
        color: #212121;
      }

      paper-button.addEntryButton {
        color: #333;
        min-width: 150px;
        background: #fefefe;
        margin-bottom: 40px;
        font-size: 80%;
        text-transform: uppercase;
      }

      paper-button.addEntryButton iron-icon {
        width: 16px;
        height: 16px;
        margin-right: 5px;
      }

      paper-button[active] {
        background-color: #4c9d2f;
        color: white;
      }

      :host paper-card.menutools-container {
        width: 100%;
      }

      :host paper-card.menutools-container {
        background-color: white;
        width: 100%;
      }

      :host paper-card.menutools-container .card-content {
        background-color: white;
        padding: 0;
      }

      :host bloombox-strain,
      :host bloombox-apothecary,
      :host bloombox-edible,
      :host bloombox-concentrate,
      :host bloombox-cartridge,
      :host bloombox-preroll {
        margin-bottom: 20px;
        width: 100%;
      }

      :host .menu-content {
        margin-top: 20px;
      }

      :host bloombox-product-list {
        width: 420px;
        height: 100%;
        flex: 1 0 400px;
      }

      :host div.product-detail-pane {
        min-height: 400px;
        position: relative;
        flex: 1 1 60%;
        padding: 20px;
      }

      :host #menuWrap {
        display: flex;
        background-color: #fefefe;
        margin: 210px 40px 20px 40px;
      }

      :host #productsContainer {
        position: relative;
      }

      :host #menuPages {
        flex: 1 1 300px;
        display: flex;
        overflow-y: scroll;
      }

      :host .selected-products {
        flex: 1 1 80%;
        padding: 20px;
      }

      :host .selected-products h2 {
        margin-left: 5px;
      }

      :host .bulk-actions {
        position: absolute;
        bottom: 40px;
      }

      :host .menu-page {
        display: flex;
        flex: 1 1 80%;
      }

      :host paper-tab[disabled] {
        opacity: 0.7;
      }
    </style>

    <!-- Firebase Collections -->
    <firebase-document
      id="dataCollection"
      log$="[[debug]]"
      path="[[_menuEndpoint]]/[[section]]"
      data="{{products}}"></firebase-document>

    <!-- Card UI -->
    <paper-card class="fullwidth menutools-container">
      <div class="menu-tools toolbar-content card-content">
        <bloombox-menutools
          instock="{{instock}}"
          sale="{{onsale}}"
          display-mode="{{_menuDisplayMode}}"
          locations="[[locations]]"
          location="{{location}}"
          disabled="[[loading]]"></bloombox-menutools>
      </div><!-- end div.toolbar-content.card-content -->

      <!-- Menu Navigation (categories) -->
      <div class="menu-nav">
        <paper-tabs selected="{{section}}" attr-for-selected="key" noink disabled="[[loading]]">
          <paper-tab key="flowers">Flowers</paper-tab>
          <paper-tab key="edibles" disabled>Edibles</paper-tab>
          <paper-tab key="concentrates" disabled>Concentrates</paper-tab>
          <paper-tab key="prerolls" disabled>Pre-Rolls</paper-tab>
          <paper-tab key="apothecary" disabled>Apothecary</paper-tab>
          <paper-tab key="cartridges" disabled>Cartridges</paper-tab>
        </paper-tabs>
      </div><!-- end div.menu-nav -->
    </paper-card><!-- end .paper-card.menutools-container -->

    <div id="menuWrap" class="menu-content layout fit">
      <div id="productsContainer" class="products-list-container layout fit vertical">
        <bloombox-product-list
          id="productList"
          section="[[section]]"
          heading="[[heading]]"
          products="[[products]]"
          selected-items="{{_selected}}"
          search="{{search}}"
          multiselect="{{multiselect}}"></bloombox-product-list>
      </div><!-- end div.products-list-container -->

      <template is="dom-if" if="[[multiselect]]">
        <div class="selected-products">
          <template is="dom-if" if="[[_hasSelectedItems]]">
            <h2>Selected products:</h2>
            <ul>
            <template class="multiselect-list" is="dom-repeat" items="[[selectedItems]]">
              <li>[[item.value.name]]</li>
            </template>
            </ul>
          </template>
          <template is="dom-if" if="[[!_hasSelectedItems]]">
            <h2>Select multiple products to perform bulk edits.</h2>
          </template>

          <div class="bulk-actions">
            <paper-button raised on-tap="bulkMarkAsInStock" disabled="[[!_hasSelectedItems]]"><iron-icon icon="done"></iron-icon>Mark as In-Stock</paper-button>
            <paper-button raised on-tap="bulkMarkAsOutOfStock" disabled="[[!_hasSelectedItems]]"><iron-icon icon="clear"></iron-icon>Mark as Out of Stock</paper-button>
            <paper-button raised on-tap="bulkDelete" disabled="[[!_hasSelectedItems]]"><iron-icon icon="delete"></iron-icon>Delete</paper-button>
          </div><!-- end div.bulk-actions -->
        </div><!-- end div.selected-products -->
      </template>

      <iron-pages id="menuPages" selected="{{section}}" attr-for-selected="section" hidden$="[[multiselect]]">
        <div class="menu-page flowers-menu-page" section="flowers">
          <!-- Product Detail -->
          <div class="product-detail-pane">
            <bloombox-strain
              key="[[selectedItem.key]]"
              partner="[[partner]]"
              environment="[[environment]]"
              name="[[selectedItem.value.name]]"
              pricing="[[formatPricelist(selectedItem.value.pricelist)]]"
              grow="[[_processGrowValue(selectedItem.value.grow)]]"
              species="[[_processSpeciesValue(selectedItem.value.species)]]"
              visible="[[_processVisible(selectedItem.value.flags.visible)]]"
              description$="[[selectedItem.value.description]]"
              tests$="[[_processTests(selectedItem.value.tests)]]"
              ancestry$="[[selectedItem.value.ancestry]]"
              sale$="[[selectedItem.value.flags.sale]]"
              bogo$="[[selectedItem.value.flags.bogo]]"
              premium$="[[selectedItem.value.flags.premium]]"
              pictures$="[[selectedItem.value.pictures]]"
              display-mode="[[_menuDisplayMode]]"
              hidden$="[[!selectedItem]]"
              disabled="[[loading]]"></bloombox-strain><!-- end bloombox-strain -->
          </div><!-- end div.product-detail-pane -->
        </div><!-- end div.menu-page.flowers-menu-page -->

        <div class="menu-page edibles-menu-page" section="edibles">
        </div><!-- end div.menu-page.edibles-menu-page -->

        <div class="menu-page concentrates-menu-page" section="concentrates">
        </div><!-- end div.menu-page.concentrates-menu-page -->

        <div class="menu-page prerolls-menu-page" section="prerolls">
        </div><!-- end div.menu-page.prerolls-menu-page -->

        <div class="menu-page apothecary-menu-page" section="apothecary">
        </div><!-- end div.menu-page.apothecary-menu-page -->

        <div class="menu-page cartridges-menu-page" section="cartridges">
        </div><!-- end div.menu-page.cartridges-menu-page -->
      </iron-pages><!-- end iron-pages#menuPages -->
    </div><!-- end div#menuWrap.menu-content -->
  </template>

  <script>
    var BloomboxLocationCache = {};

    Polymer.BloomboxPageMenu = Polymer({
      is: 'bloombox-page-menu',
      properties: {
        _menuEndpoint: {
          type: String,
          notify: true,
          computed: '_computeMenuEndpoint(endpoint, location)'
        },

        _hasSelectedItems: {
          type: Boolean,
          notify: true,
          computed: '_computeHasSelectedItems(multiselect, selectedItems)'
        },

        debug: {
          type: Boolean,
          notify: true,
          value: function() {
            return window && window["__debug"] || false;
          }
        },

        zerostate: {
          type: Boolean,
          notify: true,
          value: false
        },

        loading: {
          type: Boolean,
          notify: true
        },

        storage: {
          type: String,
          notify: true
        },

        partner: {
          type: String,
          notify: true
        },

        products: {
          type: Object,
          notify: true,
        },

        section: {
          type: String,
          notify: true,
          value: 'flowers'
        },

        heading: {
          type: String,
          notify: true,
          computed: '_computeSectionHeading(section)'
        },

        locations: {
          type: Array,
          notify: true,
          observer: '_locationsLoaded',
          value: function() {
            return window["bloom"] ? bloom.app.locations : [];
          }
        },

        location: {
          type: String,
          notify: true,
          observer: '_locationChanged'
        },

        instock: {
          type: Boolean,
          value: false,
          notify: true
        },

        endpoint: {
          type: String,
          notify: true
        },

        multiselect: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true,
          value: false
        },

        _selected: {
          type: Array,
          notify: true
        },

        selectedItem: {
          type: Object,
          notify: true
        },

        selectedItems: {
          type: Array,
          notify: true,
          computed: '_computeSelectedItems(multiselect, _selected.*)'
        },

        search: {
          type: String,
          nofity: true
        }
      },

      _toArray: function(obj) {
        return Object.keys(obj).map(function(key) {
          return {
            key: key,
            value: obj[key]
          };
        });
      },

      _computeMenuEndpoint: function(endpoint, location) {
        return endpoint + "/locations/" + location + "/menu";
      },

      _computeSectionHeading: function(section) {
        // @TODO: better section heading definitions
        return section.charAt(0).toUpperCase() + section.slice(1);
      },

      _computeSelectedItems: function(multiselect, selected) {
        if (multiselect != true) {
          if (Array.isArray(selected.base) && selected.base.length > 0) {
            this.selectedItem = selected.base[0];
            return selected.base;
          }
          if (selected.value !== null && typeof selected.value === "object" && typeof selected.value.key === "string") {
            this.selectedItem = selected.value;
            return [selected.value];
          }
        } else {
          if (Array.isArray(selected.base) && selected.base.length > 0) {
            this.selectedItem = null;
            this._selectedItemsDidChange();
            return selected.base;
          }
        }
        this.selectedItem = null;
        return [];
      },

      _selectedItemsDidChange: function() {
        var lists = Polymer.dom(this.root).querySelectorAll(".multiselect-list"),
            i;
        if (lists && lists.length > 0) {
          for (i in lists) {
            lists[i].render();
          }
        }
      },

      _locationsLoaded: function(locations) {
        var location = this.location;

        BloomboxLocationCache = {};
        for (l in locations) {
          BloomboxLocationCache[locations[l].key] = locations[l];
        }

        if (location == null || location == undefined) {
          this.location = locations[0].key;
        }
      },

      _processVisible: function(flagValue) {
        if (flagValue === false)
          return false;
        return true;
      },

      _processGrowValue: function(grow) {
        if (grow != null && grow != undefined && typeof grow === "string")
          return grow;
        return "Unknown Grow";
      },

      _processSpeciesValue: function(species) {
        if (species != null && species != undefined && typeof species === "string")
          return species;
        return "Unknown Species";
      },

      _processTests: function(tests) {
        if (tests != null && tests != undefined && typeof tests === "object") {
          if (tests.terpenes != null && tests.terpenes != undefined && typeof tests.terpenes === "object") {
            return {
              cbd: tests.cbd || 0,
              thc: tests.thc || 0,
              terpenes: tests.terpenes
            };
          }
          return {
            cbd: tests.cbd || 0,
            thc: tests.thc || 0
          };
        }
        return false;  // removes the `tests` attribute entirely
      },

      _locationChanged: function(location) {
        console.info("Loading menu for location '" + location + "'...");
      },

      _shouldHideProduct: function(instock, product) {
        if (instock && product && product.value && product.value.flags && !product.value.flags.visible)
          return true;
        return false;
      },

      _computeHasSelectedItems: function(multiselect, selectedItems) {
        return (multiselect == true && Array.isArray(selectedItems) && selectedItems.length > 0);
      },

      formatPricelist: function(pricelist) {
        if (pricelist == null) {
          return [];
        }
        return [
          {"label": "1g", "available": pricelist["gram"]["available"], "price": pricelist["gram"]["price"]},
          {"label": "3.5g", "available": pricelist["eighth"]["available"], "price": pricelist["eighth"]["price"]},
          {"label": "7g", "available": pricelist["quarter"]["available"], "price": pricelist["quarter"]["price"]},
          {"label": "14g", "available": pricelist["half"]["available"], "price": pricelist["half"]["price"]},
          {"label": "28g", "available": pricelist["ounce"]["available"], "price": pricelist["ounce"]["price"]}
        ];
      },

      toggleAddEntry: function(schema) {
        var section = (typeof schema === "string") ? schema : this.section,
            newObjEntry = this.$$("." + section + "-create-container .newEntry"),
            newObjButton = this.$$("." + section + "-menu-page .addEntryButton");

        if (newObjButton.hasAttribute("active") || newObjButton.active === true) {
          // button is active: show the component
          newObjEntry.removeAttribute("hidden");
          this.zerostate = true;
        } else {
          // button is not active: hide the component
          newObjEntry.setAttribute("hidden", true);
          this.zerostate = false;
        }
      },

      hideAddEntry: function(schema) {
        var section = (typeof schema === "string") ? schema : this.section,
            newObjEntry = this.$$("." + section + "-create-container .newEntry"),
            newObjButton = this.$$("." + section + "-menu-page .addEntryButton");

        newObjEntry.setAttribute("hidden", true);
        newObjButton.active = false;
        newObjButton.deleteAttribute("active");
      },

      attachAsset: function(mediaElement, callback) {
        // callback(uuid, error);
        var targetName = mediaElement.getNewFileName(),
            fileObject = mediaElement.getFile(),
            resolvedPath = this.generateAssetURL(targetName),
            firebase = window["firebase"] || this["firebase"] || null,
            uploadTask;
        if (firebase === null) {
          console.error("Unable to resolve Firebase library. Failing asset attachment call.");
          callback(null, "DATABASE_ERROR");
        } else {
          uploadTask = firebase.storage().ref.child(resolvedPath).put(fileObject.file);
          uploadTask.on("state_changed", function(snapshot) {
            // Handle progress events
            var progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
            console.log("Media upload completion: ", progress);
            mediaElement.setProgress(progress);
          }, function(error) {
            // Handle unsuccessful uploads
            console.error("Error occurred during media upload:", error);
            callback(null, error);
          }, function() {
            // Handle completion
            var downloadURL = uploadTask.snapshot.downloadURL;
            console.log("New asset is available at download URL: ", downloadURL);
            callback(targetName, undefined);
          });
        }
      },

      generateAssetURL: function(targetName) {
        var prefix = this.get("storage");
        if (!prefix)
          console.warn("Unable to resolve storage prefix. Uploads may break.");
        return prefix + "/" + targetName;
      },

      saveNewObject: function(schema, entry, component, callback) {
        var debug = window["__debug"] || false,
            that = this,
            newObjKey;

        // perform our object write
        newObjKey = this.$.dataCollection.ref.child(schema).push().key;
        if (debug) {
          console.log("Provisioned key for new item: '" + newObjKey + "'.", entry);
        }
        return this.$.dataCollection.ref
                            .child(newObjKey)
                            .update(entry)
                            .then(function() {
                              // we are no longer in zerostate
                              that.zerostate = false;
                              if (callback !== undefined && typeof callback === "function") {
                                callback();
                              }
                            })
                            .catch(function(error) {
                              console.error("Encountered error persisting new object of type '" + schema + "'.", error);
                              that.toggleAddEntry(schema);
                              callback(error);
                            });
      },

      saveEditsForEntry: function(schema, key, previous, entry, callback) {
        var debug = window["__debug"] || false;
        if (debug) {
          console.log("Saving edits for item of type '" + schema + "' at key: '" + key + "'.", entry);
        }
        return this.$.dataCollection.ref
                            .child(key)
                            .update(entry)
                            .then(callback)
                            .catch(function(error) {
                              console.error("Encountered error persisting edits for object of type '" + schema + "'.", error);
                              callback(error);
                            });
      },

      deleteEntryAtId: function(schema, key) {
        var debug = window["__debug"] || false;

        if (debug) {
          console.log("Deleting item of type '" + schema + "' at key '" + key + "'.");
        }
        return this.$.dataCollection.ref
                            .child(key)
                            .remove();
      },

      _applyWritesToProducts: function(schema, products, isDelete, callback) {
        var updates = {}, i, p, schema;
        if (!Array.isArray(products) || products.length < 1) {
          callback(false);
          return;
        }

        // map writes into one bulk update
        for (i in products) {
          p = products[i];
          updates[p.key] = isDelete ? null : p.value;
        }

        return this.$.dataCollection.ref
                            .update(updates)
                            .then(function() {
                              callback(true);
                            })
                            .catch(function(error) {
                              console.error("Encountered error persisting edits for object of type '" + schema + "'.", error);
                              callback(false, error);
                            });
      },

      _mapForEachProduct: function(products, callback) {
        var i, p, processed = [], buffered = JSON.parse(JSON.stringify(products));
        if (Array.isArray(buffered) && buffered.length > 0) {
          for (i in buffered) {
            p = buffered[i];
            callback(p);
            processed.push(p);
          }
          return processed;
        }
        return [];
      },

      clearSelection: function() {
        this.$.productList.clearSelection();
      },

      bulkMarkAsInStock: function(event) {
        var products = this.selectedItems,
            that = this,
            section = this.section;
        event.preventDefault();
        event.stopPropagation();
        writes = this._mapForEachProduct(products, function(product) {
          if (product.value.flags !== undefined) {
            product.value.flags.visible = true;
          } else {
            product.value.flags = {
              visible: true
            };
          }
        });
        console.info("User requested bulk mark-as-in-stock:", products);
        bloom.app.confirmToast("Mark " +
                               (products.length > 1 ? products.length + " " : "") +
                               "selected " +
                               (products.length > 1 ? "items" : "item") + " as in stock?", function(yes, toast) {
                                  if (yes) {
                                    console.log("User confirmed bulk operation. Executing...");
                                    that._applyWritesToProducts(section, writes, false, function(success) {
                                      if (success) {
                                        // okay everything worked
                                        console.log("Bulk operation finished.");
                                        toast.close();
                                        setTimeout(function() {
                                          that.clearSelection();
                                          that.multiselect = false;
                                          bloom.app.successToast("Successfully marked " + products.length + " " +
                                                                (products.length > 1 ? "items" : "item") +
                                                                " as in-stock.")
                                        }, 120);
                                      } else {
                                        // something broke
                                        console.error("Failed to apply bulk operation.");
                                        toast.close();
                                        setTimeout(function() {
                                          bloom.app.errorToast("Bulk edit operation failed. Please try again.");
                                        });
                                      }
                                    });
                                    return true;  // we will handle closing it
                                  } else {
                                    console.log("User rejected bulk operation. Cancelling.");
                                  }
                                  return false;  // close the dialog for us plz
                               });
      },

      bulkMarkAsOutOfStock: function(event) {
        var products = this.selectedItems,
            that = this,
            section = this.section,
            writes;
        event.preventDefault();
        event.stopPropagation();
        writes = this._mapForEachProduct(products, function(product) {
          if (product.value.flags !== undefined) {
            product.value.flags.visible = false;
          } else {
            product.value.flags = {visible: false};
          }
        });
        console.info("User requested bulk mark-as-out-of-stock:", products);
        bloom.app.confirmToast("Mark " +
                               (products.length > 1 ? products.length + " " : "") +
                               "selected " +
                               (products.length > 1 ? "items" : "item") + " as out-of-stock?", function(yes, toast) {
                                  if (yes) {
                                    console.log("User confirmed bulk operation. Executing...");
                                    that._applyWritesToProducts(section, writes, false, function(success) {
                                      if (success) {
                                        // okay everything worked
                                        console.log("Bulk operation finished.");
                                        toast.close();
                                        setTimeout(function() {
                                          that.clearSelection();
                                          that.multiselect = false;
                                          bloom.app.successToast("Successfully marked " + products.length + " " +
                                                                (products.length > 1 ? "items" : "item") +
                                                                " as out-of-stock.")
                                        }, 120);
                                      } else {
                                        // something broke
                                        console.error("Failed to apply bulk operation.");
                                        toast.close();
                                        setTimeout(function() {
                                          bloom.app.errorToast("Bulk edit operation failed. Please try again.");
                                        });
                                      }
                                    });
                                    return true;  // we will handle closing it
                                  } else {
                                    console.log("User rejected bulk operation. Cancelling.");
                                  }
                                  return false;  // close the dialog for us plz
                               });
      },

      bulkDelete: function(event) {
        var products = this.selectedItems,
            that = this,
            section = this.section,
            writes;
        event.preventDefault();
        event.stopPropagation();
        console.info("User requested bulk delete:", products);
        bloom.app.confirmToast("Delete " +
                               (products.length > 1 ? products.length + " " : "") +
                               "selected " +
                               (products.length > 1 ? "items" : "item") + "?", function(yes, toast) {
                                  if (yes) {
                                    console.log("User confirmed bulk delete. Executing...");
                                    that._applyWritesToProducts(section, products, true, function(success) {
                                      if (success) {
                                        // okay everything worked
                                        console.log("Bulk delete operation finished.");
                                        toast.close();
                                        setTimeout(function() {
                                          that.clearSelection();
                                          that.multiselect = false;
                                          bloom.app.successToast("Successfully deleted " + products.length + " " +
                                                                (products.length > 1 ? "items" : "item") + ".")
                                        }, 120);
                                      } else {
                                        // something broke
                                        console.error("Failed to execute bulk delete operation.");
                                        toast.close();
                                        setTimeout(function() {
                                          bloom.app.errorToast("Bulk delete failed. Please try again.");
                                        });
                                      }
                                    });
                                    return true;  // we will handle closing it
                                  } else {
                                    console.log("User rejected bulk delete. Cancelling.");
                                  }
                                  return false;  // close the dialog for us plz
                               });
      },

      ready: function() {
        var bloom = window["bloom"];
        if (bloom !== undefined && bloom != null) {
          bloom.menu = this;  // provide menu engine to JS context
        } else {
          window["bloom"] = {
            menu: this
          };
        }
      }
    });
  </script>
</dom-module>
